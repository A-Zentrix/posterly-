from PIL import Image, ImageDraw, ImageFont
import os
from uuid import uuid4

def add_watermark(image_path: str, text: str = "Generated by A-Zentrix", output_dir: str = "static/posters") -> str | None:
    """
    Adds a text watermark to an image.

    Args:
        image_path: Path to the input image.
        text: The watermark text.
        output_dir: The directory to save the watermarked image.

    Returns:
        The path to the saved watermarked image, or None if an error occurred.
    """
    try:
        # --- 1. Check if input file exists ---
        if not os.path.exists(image_path):
            print(f"Error: Input image not found at {image_path}")
            return None

        # --- 2. Load the image ---
        # Use 'with' statement for better resource management
        with Image.open(image_path) as base:
            # Ensure image is RGBA for transparency operations
            if base.mode != 'RGBA':
                base = base.convert("RGBA")

            # --- 3. Create transparent overlay ---
            watermark_layer = Image.new("RGBA", base.size, (255, 255, 255, 0)) # Fully transparent layer
            draw = ImageDraw.Draw(watermark_layer)

            # --- 4. Choose a font ---
            font_size = 36
            font_path = "arial.ttf" # Common font, but might not be on all systems/paths
            try:
                # Try loading the specific font
                font = ImageFont.truetype(font_path, font_size)
                # print(f"Using font: {font_path}") # Optional: for debugging
            except IOError:
                print(f"Warning: Font '{font_path}' not found. Using default font.")
                # Fallback to default font if specific one isn't found
                try:
                    font = ImageFont.load_default()
                    # Note: Default font doesn't support size argument directly in older Pillow versions
                    # You might need to adjust positioning logic or find a guaranteed font
                except Exception as e:
                    print(f"Error loading default font: {e}")
                    return None # Cannot proceed without a font

            # --- 5. Calculate text position (using textbbox) ---
            # Get the bounding box of the text if drawn at (0,0)
            # Arguments: xy, text, draw=None, font=None, anchor=None, spacing=4, align='left', direction=None, features=None, language=None, stroke_width=0, embedded_color=False
            try:
                # We need the draw object to measure text with the specific font
                 # Using (0,0) as reference point for bbox calculation
                text_bbox = draw.textbbox((0, 0), text, font=font)
                # text_bbox is (left, top, right, bottom)
                textwidth = text_bbox[2] - text_bbox[0]
                textheight = text_bbox[3] - text_bbox[1]
            except AttributeError:
                 # Fallback for older Pillow versions that might not have textbbox on Draw object directly
                 # or if default font doesn't work well with bbox. This is less accurate.
                 print("Warning: Using legacy textlength/font metrics for positioning.")
                 try:
                     textwidth = draw.textlength(text, font=font)
                     # Estimating height can be tricky with legacy methods/default font
                     # Use a fixed value or font metric if available
                     ascent, descent = font.getmetrics()
                     textheight = ascent + descent # Approximate height
                 except AttributeError: # Handle default font limitations
                     print("Warning: Cannot accurately determine text height with this font. Using fallback estimate.")
                     textwidth = len(text) * font_size * 0.6 # Very rough estimate
                     textheight = font_size # Very rough estimate


            margin = 40
            x = base.width - textwidth - margin
            y = base.height - textheight - margin

            # Ensure coordinates are non-negative
            x = max(x, 0)
            y = max(y, 0)

            # --- 6. Add the text to the transparent layer ---
            text_fill = (255, 255, 255, 180) # white semi-transparent
            draw.text((x, y), text, font=font, fill=text_fill)

            # --- 7. Merge watermark layer with base image ---
            # alpha_composite requires both images to be RGBA and same size
            watermarked = Image.alpha_composite(base, watermark_layer)

            # --- 8. Prepare output path and directory ---
            # Ensure the output directory exists
            os.makedirs(output_dir, exist_ok=True) # exist_ok=True prevents error if dir exists

            # Generate unique filename
            output_filename = f"final_{uuid4().hex}.png"
            output_path = os.path.join(output_dir, output_filename)

            # --- 9. Save the final result ---
            # Save as PNG to preserve transparency
            watermarked.save(output_path, "PNG")
            print(f"Watermarked image saved to: {output_path}")
            return output_path

    except FileNotFoundError:
         print(f"Error: Input image not found at {image_path}")
         return None
    except IOError as e:
        # Catches font loading errors not handled by inner try-except,
        # or other image file issues
        print(f"Error processing image or font: {e}")
        return None
    except Exception as e:
        # Catch any other unexpected errors
        print(f"An unexpected error occurred: {e}")
        # import traceback # Uncomment for detailed debugging
        # traceback.print_exc() # Uncomment for detailed debugging
        return None

# --- How to use it ---
# Make sure the output directory structure is desired relative to your script's location
# or provide an absolute path for output_dir.

# Example call:
input_image = r"D:\\client project\\backend\\hello6.png" # Use raw string for Windows paths
# input_image = "/path/to/your/image.jpg" # Example for Linux/macOS

result_path = add_watermark(input_image)

if result_path:
    print(f"Successfully created watermarked image: {result_path}")
else:
    print("Failed to create watermarked image.")

# Example call with different text and output dir:
# result_path_custom = add_watermark(input_image, text="My Custom Watermark Â©", output_dir="output/watermarked_images")
# if result_path_custom:
#     print(f"Successfully created custom watermarked image: {result_path_custom}")
# else:
#     print("Failed to create custom watermarked image.")